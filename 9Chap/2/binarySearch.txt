T (n) = T(n/2) + O(1)   :   O(1) 时间做 i f比较 将问题变为 T(n/2) 时间的问题，依次往下， 最后累积成  log n * O(1)  =  O(log n)

T( n ) = T( n / 2 ) + O( n ) :  2n => O( n )


判断是否用二分法，复杂度log n或者看数据是否具有单调性

模版最后将大区间缩小到了仅含 start，end的长度为2的区间 (start + 1 < end)

mid = start + (end - start) / 2;     防止溢出 (start + end) / 2 可能先溢出后除2

出错时带着例子执行一下自己的代码

第二境界
二分，前面都满足条件，后面都不满足，找第一个不满足或者最后一个满足的位置
倍增法： log n     -》   最大为2147483674

拿到题目一定要知道如何用暴力算法解

log 有关 一般由排序或者 binary search   =》 up，bottom，left， right =》 找第一列有黑点的， 以及最后一列有黑点的， 
第一行有黑点的和最后一行有黑点的

find peak： 按照上升下降来选择start end 的位置

切开之后，用代数将两部分的区间分别表示出来，然后判断在哪一边
